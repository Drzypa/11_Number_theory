<!DOCTYPE html><html>
<head>
<title>Pollard’s ρ</title>
<!--Generated on Fri Feb  9 15:20:25 2018 by LaTeXML (version 0.8.2) http://dlmf.nist.gov/LaTeXML/.-->

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="LaTeXML.css" type="text/css">
<link rel="stylesheet" href="ltx-article.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/3f71ceeb3b055e1ddc3b6c11fb1f074c/raw/2bb23e3b173ff96840797fc0c3bcb8c54085df8e/LaTeXML.css" type="text/css">
<link rel="stylesheet" href="https://cdn.rawgit.com/holtzermann17/4bda0365b30858ac2fb83623185fe3ec/raw/cedd84ed3e3ad597c5d293f443ecfe4803741c6b/ltx-article.css" type="text/css">
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line">
<h1 class="ltx_title ltx_title_document">Pollard’s <math id="m1" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math>
</h1>

<div id="p1" class="ltx_para">
<br class="ltx_break">
</div>
<div id="p2" class="ltx_para">
<p class="ltx_p"><em class="ltx_emph ltx_font_italic">Pollard’s <math id="p2.m1" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math> method</em> is an algorithm for factoring numbers, better than trial and error for larger numbers.</p>
</div>
<div id="p3" class="ltx_para">
<p class="ltx_p">Let <math id="p3.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> a non prime number and <math id="p3.m2" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> a non trivial factor. The actual value of the factors are unknown at this stage, and Pollard’s <math id="p3.m3" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math> provides a way to find them. We do know, however, than <math id="p3.m4" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> is not larger than <math id="p3.m5" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. In fact, we know at least one of the factors must hold <math id="p3.m6" class="ltx_Math" alttext="d\leq\sqrt{n}" display="inline"><mrow><mi>d</mi><mo>≤</mo><msqrt><mi>n</mi></msqrt></mrow></math>, so we assume this condition.</p>
</div>
<div id="p4" class="ltx_para">
<p class="ltx_p">So, how does this help? If you start picking numbers at random
(keeping your numbers greater or equal to zero and strictly less
than <math id="p4.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>), then the only time you will get <math id="p4.m2" class="ltx_Math" alttext="a\equiv b\mod n" display="inline"><mrow><mi>a</mi><mo>≡</mo><mrow><mi>b</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>n</mi></mrow></mrow></math> is
when <math id="p4.m3" class="ltx_Math" alttext="a" display="inline"><mi>a</mi></math> and <math id="p4.m4" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math> are identical. However, since <math id="p4.m5" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> is smaller than
<math id="p4.m6" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>, there is a good chance that <math id="p4.m7" class="ltx_Math" alttext="a\equiv b\mod d" display="inline"><mrow><mi>a</mi><mo>≡</mo><mrow><mi>b</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>d</mi></mrow></mrow></math> sometimes when
<math id="p4.m8" class="ltx_Math" alttext="a\neq b" display="inline"><mrow><mi>a</mi><mo>≠</mo><mi>b</mi></mrow></math>.</p>
</div>
<div id="p5" class="ltx_para">
<p class="ltx_p">Well, if <math id="p5.m1" class="ltx_Math" alttext="a\equiv b\mod d" display="inline"><mrow><mi>a</mi><mo>≡</mo><mrow><mi>b</mi><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>d</mi></mrow></mrow></math>, that means that <math id="p5.m2" class="ltx_Math" alttext="(a-b)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></math> is a multiple of
<math id="p5.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. Since <math id="p5.m4" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> is also a multiple of <math id="p5.m5" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>, the greatest common
divisor of <math id="p5.m6" class="ltx_Math" alttext="(a-b)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></math> and <math id="p5.m7" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> is a positive, integer multiple of <math id="p5.m8" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>.
We can keep picking numbers randomly until the greatest common
divisor of <math id="p5.m9" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> and the difference of two of our random numbers is
greater than one. Then, we can divide <math id="p5.m10" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> by whatever this greatest
common divisor turned out to be. In doing so, we have broken down
<math id="p5.m11" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> into two factors. If we suspect that the factors may be
composite, we can continue trying to break them down further by
doing the algorithm again on each half.</p>
</div>
<div id="p6" class="ltx_para">
<p class="ltx_p">The amazing thing here is that through all of this, we just knew
there had to be some divisor of <math id="p6.m1" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. We were able to use properties
of that divisor to our advantage <em class="ltx_emph ltx_font_italic">before</em> we even knew what the
divisor was!</p>
</div>
<div id="p7" class="ltx_para">
<p class="ltx_p">This is at the heart of Pollard’s rho method. Pick a random number
<math id="p7.m1" class="ltx_Math" alttext="a" display="inline"><mi>a</mi></math>. Pick another random number <math id="p7.m2" class="ltx_Math" alttext="b" display="inline"><mi>b</mi></math>. See if the greatest common
divisor of <math id="p7.m3" class="ltx_Math" alttext="(a-b)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></math> and <math id="p7.m4" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> is greater than one. If not, pick
another random number <math id="p7.m5" class="ltx_Math" alttext="c" display="inline"><mi>c</mi></math>. Now, check the greatest common divisor
of <math id="p7.m6" class="ltx_Math" alttext="(c-b)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>c</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></math> and <math id="p7.m7" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. If that is not greater than one, check the
greatest common divisor of <math id="p7.m8" class="ltx_Math" alttext="(c-a)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>c</mi><mo>-</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></math> and <math id="p7.m9" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. If that doesn’t work,
pick another random number <math id="p7.m10" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. Check <math id="p7.m11" class="ltx_Math" alttext="(d-c)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>-</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow></math>, <math id="p7.m12" class="ltx_Math" alttext="(d-b)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>-</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow></math>, and <math id="p7.m13" class="ltx_Math" alttext="(d-a)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>d</mi><mo>-</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow></math>.
Continue in this way until you find a factor.</p>
</div>
<div id="p8" class="ltx_para">
<p class="ltx_p">As you can see from the above paragraph, this could get quite
cumbersome quite quickly. By the <math id="p8.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-th iteration, you will have
to do <math id="p8.m2" class="ltx_Math" alttext="(k-1)" display="inline"><mrow><mo stretchy="false">(</mo><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></math> greatest common divisor checks. Fortunately, there
is way around that. By structuring the way in which you pick
“random” numbers, you can avoid this buildup.</p>
</div>
<div id="p9" class="ltx_para">
<p class="ltx_p">We use an appropiate polynomial <math id="p9.m1" class="ltx_Math" alttext="f(x)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> to generate pseudorandom numbers. Because we’re only concerned with numbers from
zero up to (but not including) <math id="p9.m2" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>, we will take all of the values
of <math id="p9.m3" class="ltx_Math" alttext="f(x)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> modulo <math id="p9.m4" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. We start with some <math id="p9.m5" class="ltx_Math" alttext="x_{1}" display="inline"><msub><mi>x</mi><mn>1</mn></msub></math>. We then pick our
numbers by taking <math id="p9.m6" class="ltx_Math" alttext="x_{k+1}=(f(x_{k})\mod n)" display="inline"><mrow><msub><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
<div id="p10" class="ltx_para">
<p class="ltx_p">Now, say for example we get to some point <math id="p10.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> where <math id="p10.m2" class="ltx_Math" alttext="x_{k}\equiv x_{j}\mod d" display="inline"><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>≡</mo><mrow><msub><mi>x</mi><mi>j</mi></msub><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>d</mi></mrow></mrow></math> with <math id="p10.m3" class="ltx_Math" alttext="k&lt;j" display="inline"><mrow><mi>k</mi><mo>&lt;</mo><mi>j</mi></mrow></math>. Then, because of the way that modulo
arithmetic works, <math id="p10.m4" class="ltx_Math" alttext="f(x_{k})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> will be congruent to <math id="p10.m5" class="ltx_Math" alttext="f(x_{j})" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></math> modulo
<math id="p10.m6" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. So, once we hit upon <math id="p10.m7" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math> and <math id="p10.m8" class="ltx_Math" alttext="x_{j}" display="inline"><msub><mi>x</mi><mi>j</mi></msub></math>, then each element in
the sequence starting with <math id="p10.m9" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math> will be congruent modulo <math id="p10.m10" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> to
the corresponding element in the sequence starting at <math id="p10.m11" class="ltx_Math" alttext="x_{j}" display="inline"><msub><mi>x</mi><mi>j</mi></msub></math>. Thus,
once the sequence gets to <math id="p10.m12" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math> it has looped back upon itself to
match up with <math id="p10.m13" class="ltx_Math" alttext="x_{j}" display="inline"><msub><mi>x</mi><mi>j</mi></msub></math> (when considering them modulo <math id="p10.m14" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>).</p>
</div>
<div id="p11" class="ltx_para">
<p class="ltx_p">This looping is what gives the <math id="p11.m1" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math> method its name. If you go back
through (once you determine <math id="p11.m2" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>) and look at the sequence of random
numbers that you used (looking at them modulo <math id="p11.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>), you will see
that they start off just going along by themselves for a bit.
Then, they start to come back upon themselves. They don’t typically
loop the whole way back to the first number of your sequence. So,
they have a bit of a tail and a loop—just like the Greek letter
rho (<math id="p11.m4" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math>).</p>
</div>
<div id="p12" class="ltx_para">
<p class="ltx_p">Before we see why that looping helps, we will first speak to why
it has to happen. When we consider a number modulo <math id="p12.m1" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>, we are
only considering the numbers greater than or equal to zero and
strictly less than <math id="p12.m2" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. This is a very finite set of numbers.
Your random sequence cannot possibly go on for more than <math id="p12.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> numbers
without having some number repeat modulo <math id="p12.m4" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. And, if the function
<math id="p12.m5" class="ltx_Math" alttext="f(x)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> is well-chosen, you can probably loop back a great deal
sooner.</p>
</div>
<div id="p13" class="ltx_para">
<p class="ltx_p">The looping helps because it means that we can get away without
accumulating the number of greatest common divisor steps we need
to perform with each new random number. In fact, it makes it so
that we only need to do one greatest common divisor check for every
second random number that we pick.</p>
</div>
<div id="p14" class="ltx_para">
<p class="ltx_p">Now, why is that? Let’s assume that the loop is of length <math id="p14.m1" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> and
starts at the <math id="p14.m2" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math>-th random number. Say that we are on the <math id="p14.m3" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>-th
element of our random sequence. Furthermore, say that <math id="p14.m4" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> is
greater than or equal to <math id="p14.m5" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math> and <math id="p14.m6" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> divides <math id="p14.m7" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>. Because <math id="p14.m8" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math> is
greater than <math id="p14.m9" class="ltx_Math" alttext="j" display="inline"><mi>j</mi></math> we know it is inside the looping part of the
<math id="p14.m10" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math>. We also know that if <math id="p14.m11" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> divides <math id="p14.m12" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>, then <math id="p14.m13" class="ltx_Math" alttext="t" display="inline"><mi>t</mi></math> also divides
<math id="p14.m14" class="ltx_Math" alttext="2k" display="inline"><mrow><mn>2</mn><mo>⁢</mo><mi>k</mi></mrow></math>. What this means is that <math id="p14.m15" class="ltx_Math" alttext="x_{2k}" display="inline"><msub><mi>x</mi><mrow><mn>2</mn><mo>⁢</mo><mi>k</mi></mrow></msub></math> and <math id="p14.m16" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math> will be congruent
modulo <math id="p14.m17" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math> because they correspond to the same point on the loop.
Because they are congruent modulo <math id="p14.m18" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>, their difference is a multiple
of <math id="p14.m19" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. So, if we check the greatest common divisor of <math id="p14.m20" class="ltx_Math" alttext="(x_{k}-x_{k/2})" display="inline"><mrow><mo stretchy="false">(</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>/</mo><mn>2</mn></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></math>
with <math id="p14.m21" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> every time we get to an even <math id="p14.m22" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math>, we will find some factor
of <math id="p14.m23" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math> without having to do <math id="p14.m24" class="ltx_Math" alttext="k-1" display="inline"><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></math> greatest common divisor calculations
every time we come up with a new random number. Instead, we only
have to do one greatest common divisor calculation for every second
random number.</p>
</div>
<div id="p15" class="ltx_para">
<p class="ltx_p">The only open question is what to use for a polynomial
<math id="p15.m1" class="ltx_Math" alttext="f(x)" display="inline"><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></math> to get some random numbers which don’t have too
many choices modulo <math id="p15.m2" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>. Since we don’t usually know
much about <math id="p15.m3" class="ltx_Math" alttext="d" display="inline"><mi>d</mi></math>, we really can’t tailor the polynomial
too much. A typical choice of polynomial is</p>
<table id="S0.Ex1" class="ltx_equation ltx_eqn_table">

<tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S0.Ex1.m1" class="ltx_Math" alttext="f(x)=x^{2}+a" display="block"><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mi>a</mi></mrow></mrow></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr>
</table>
<p class="ltx_p">where <math id="p15.m4" class="ltx_Math" alttext="a" display="inline"><mi>a</mi></math> is
some constant which isn’t congruent to <math id="p15.m5" class="ltx_Math" alttext="0" display="inline"><mn>0</mn></math> or <math id="p15.m6" class="ltx_Math" alttext="-2" display="inline"><mrow><mo>-</mo><mn>2</mn></mrow></math>
modulo <math id="p15.m7" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>. If you don’t place those restrictions on
<math id="p15.m8" class="ltx_Math" alttext="a" display="inline"><mi>a</mi></math>, then you will end up degenerating into the sequence
<math id="p15.m9" class="ltx_Math" alttext="\{1,1,1,1,...\}" display="inline"><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi mathvariant="normal">…</mi><mo stretchy="false">}</mo></mrow></math> as soon as you hit upon some <math id="p15.m10" class="ltx_Math" alttext="x" display="inline"><mi>x</mi></math>
which is congruent to either <math id="p15.m11" class="ltx_Math" alttext="1" display="inline"><mn>1</mn></math> or <math id="p15.m12" class="ltx_Math" alttext="-1" display="inline"><mrow><mo>-</mo><mn>1</mn></mrow></math> modulo
<math id="p15.m13" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math>.</p>
</div>
<div id="p16" class="ltx_para">
<p class="ltx_p">Let’s use the algorithm now to factor our number <math id="p16.m1" class="ltx_Math" alttext="16843009" display="inline"><mn>16843009</mn></math>. We
will use the sequence <math id="p16.m2" class="ltx_Math" alttext="x_{1}=1" display="inline"><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow></math> with <math id="p16.m3" class="ltx_Math" alttext="x_{n+1}=(1024x_{n}^{2}+32767\mod n)" display="inline"><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mn>1024</mn><mo>⁢</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mn>32767</mn></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>. [ I also tried it with the very basic polynomial <math id="p16.m4" class="ltx_Math" alttext="f(x)=x^{2}+1" display="inline"><mrow><mrow><mi>f</mi><mo>⁢</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow></mrow></math>, but that one went 80 rounds before stopping so I didn’t
include the table here.]</p>
</div>
<div id="p17" class="ltx_para ltx_centering">
<table class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p17.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p17.m2" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p17.m3" class="ltx_Math" alttext="\gcd(n,x_{k}-x_{k/2})" display="inline"><mrow><mi>gcd</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>/</mo><mn>2</mn></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_t">1</td>
<td class="ltx_td ltx_align_center ltx_border_t">1</td>
<td class="ltx_td ltx_border_t"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">2</td>
<td class="ltx_td ltx_align_center">33791</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">3</td>
<td class="ltx_td ltx_align_center">10832340</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">4</td>
<td class="ltx_td ltx_align_center">12473782</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">5</td>
<td class="ltx_td ltx_align_center">4239855</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">6</td>
<td class="ltx_td ltx_align_center">309274</td>
<td class="ltx_td ltx_align_center"><math id="p17.m4" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">7</td>
<td class="ltx_td ltx_align_center">11965503</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">8</td>
<td class="ltx_td ltx_align_center">15903688</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">9</td>
<td class="ltx_td ltx_align_center">3345998</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">10</td>
<td class="ltx_td ltx_align_center">2476108</td>
<td class="ltx_td ltx_align_center"><math id="p17.m5" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">11</td>
<td class="ltx_td ltx_align_center">11948879</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">12</td>
<td class="ltx_td ltx_align_center">9350010</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">13</td>
<td class="ltx_td ltx_align_center">4540646</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">14</td>
<td class="ltx_td ltx_align_center">858249</td>
<td class="ltx_td ltx_align_center"><math id="p17.m6" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">15</td>
<td class="ltx_td ltx_align_center">14246641</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">16</td>
<td class="ltx_td ltx_align_center">4073290</td>
<td class="ltx_td ltx_align_center"><math id="p17.m7" class="ltx_Math" alttext="n" display="inline"><mi>n</mi></math></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">17</td>
<td class="ltx_td ltx_align_center">4451768</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">18</td>
<td class="ltx_td ltx_align_center">14770419</td>
<td class="ltx_td ltx_align_center">257</td>
</tr>
</tbody>
</table>
</div>
<div id="p18" class="ltx_para">
<p class="ltx_p">and so we have discovered the factor <math id="p18.m1" class="ltx_Math" alttext="257" display="inline"><mn>257</mn></math>.</p>
</div>
<div id="p19" class="ltx_para">
<p class="ltx_p">Let’s try to factor again with a different random number schema.
We will use the sequence <math id="p19.m1" class="ltx_Math" alttext="x_{1}=1" display="inline"><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow></math> with <math id="p19.m2" class="ltx_Math" alttext="x_{n+1}=(2048x_{n}^{2}+32767\mod n)" display="inline"><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><mrow><mn>2048</mn><mo>⁢</mo><msubsup><mi>x</mi><mi>n</mi><mn>2</mn></msubsup></mrow><mo>+</mo><mn>32767</mn></mrow><mo lspace="2.5pt" rspace="2.5pt">mod</mo><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>.</p>
</div>
<div id="p20" class="ltx_para ltx_centering">
<table class="ltx_tabular ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p20.m1" class="ltx_Math" alttext="k" display="inline"><mi>k</mi></math></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p20.m2" class="ltx_Math" alttext="x_{k}" display="inline"><msub><mi>x</mi><mi>k</mi></msub></math></th>
<th class="ltx_td ltx_align_center ltx_th ltx_th_column"><math id="p20.m3" class="ltx_Math" alttext="\gcd(n,x_{k}-x_{k/2})" display="inline"><mrow><mi>gcd</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>,</mo><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>-</mo><msub><mi>x</mi><mrow><mi>k</mi><mo>/</mo><mn>2</mn></mrow></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math></th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center ltx_border_t">1</td>
<td class="ltx_td ltx_align_center ltx_border_t">1</td>
<td class="ltx_td ltx_border_t"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">2</td>
<td class="ltx_td ltx_align_center">34815</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">3</td>
<td class="ltx_td ltx_align_center">9016138</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">4</td>
<td class="ltx_td ltx_align_center">4752700</td>
<td class="ltx_td ltx_align_center">1</td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">5</td>
<td class="ltx_td ltx_align_center">1678844</td>
<td class="ltx_td"></td>
</tr>
<tr class="ltx_tr">
<td class="ltx_td ltx_align_center">6</td>
<td class="ltx_td ltx_align_center">14535213</td>
<td class="ltx_td ltx_align_center">257</td>
</tr>
</tbody>
</table>
</div>
<div id="p21" class="ltx_para">
<p class="ltx_p">Again, the factor <math id="p21.m1" class="ltx_Math" alttext="257" display="inline"><mn>257</mn></math> shows up.</p>
</div>
<div id="p22" class="ltx_para">
<p class="ltx_p">Pollard’s <math id="p22.m1" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math> can also be applied to other finite groups besides integers, providing one of the best known methods to computing discrete logarithms on arbitrary groups.
</p>
<table class="ltx_tabular ltx_align_right ltx_guessed_headers ltx_align_middle">
<tbody class="ltx_tbody">
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l ltx_border_t">Title</th>
<td class="ltx_td ltx_align_left ltx_border_r ltx_border_t">Pollard’s <math id="p22.m2" class="ltx_Math" alttext="\rho" display="inline"><mi>ρ</mi></math>
</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Canonical name</th>
<td class="ltx_td ltx_align_left ltx_border_r">Pollardsrho</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Date of creation</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 12:34:58</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified on</th>
<td class="ltx_td ltx_align_left ltx_border_r">2013-03-22 12:34:58</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Owner</th>
<td class="ltx_td ltx_align_left ltx_border_r">yark (2760)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Last modified by</th>
<td class="ltx_td ltx_align_left ltx_border_r">yark (2760)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Numerical id</th>
<td class="ltx_td ltx_align_left ltx_border_r">12</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Author</th>
<td class="ltx_td ltx_align_left ltx_border_r">yark (2760)</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Entry type</th>
<td class="ltx_td ltx_align_left ltx_border_r">Algorithm</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Classification</th>
<td class="ltx_td ltx_align_left ltx_border_r">msc 11A51</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Classification</th>
<td class="ltx_td ltx_align_left ltx_border_r">msc 11Y05</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_l">Synonym</th>
<td class="ltx_td ltx_align_left ltx_border_r">Pollard rho</td>
</tr>
<tr class="ltx_tr">
<th class="ltx_td ltx_align_left ltx_th ltx_th_row ltx_border_b ltx_border_l">Related topic</th>
<td class="ltx_td ltx_align_left ltx_border_b ltx_border_r">CryptographyAndNumberTheory</td>
</tr>
</tbody>
</table>
</div>
</article>
</div>
<footer class="ltx_page_footer">
<div class="ltx_page_logo">Generated  on Fri Feb  9 15:20:25 2018 by <a href="http://dlmf.nist.gov/LaTeXML/">LaTeXML <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>
</body>
</html>
